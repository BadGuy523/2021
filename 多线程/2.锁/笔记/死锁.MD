### 死锁/活锁
- 死锁： 一组互相竞争资源的线程因互相等待，导致“永久”阻塞的现象。
- 活锁： 活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，活锁有可能自行解开
### 死锁发生的条件
- 这四个条件同时满足，就会产生死锁。
1. 互斥，共享资源 X 和 Y 只能被一个线程占用；
2. 占有且等待，线程 T1 已经取得共享资源 X，在等待共享资源 Y 的时候，不释放共享资源 X；
3. 不可抢占，其他线程不能强行抢占线程 T1 占有的资源；
4. 循环等待，线程 T1 等待线程 T2 占有的资源，线程 T2 等待线程 T1 占有的资源，就是循环等待。
### 如何解决死锁问题
- 按照前面说的四个死锁的发生条件，我们只需要破坏其中一个，就可以避免死锁的产生。
- 其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥，其他三个条件都有办法可以破坏
1. 对于“占用且等待”这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
2. 对于“不可抢占”这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动
释放它占有的资源，这样不可抢占这个条件就破坏掉了。
3. 对于“循环等待”这个条件，可以靠按序申请资源来预防。所谓按序申请，是指资源是有线性顺序
的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环
了。
### Thread.join
- Thread.join，这个内容在我讲Happens-Before可见性模型的时候讲过，它的作用其实就是让线程的执
行结果对后续线程的访问可见。
