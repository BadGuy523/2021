### 简介
- Spring Cloud Config用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，分为服务端和客户端两个部分。
- 其中服务端又称为分布式配置中心，是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息；
- 而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定配置中心来管理应用资源和业务相关的配置内容。服务器存储后端的默认实现使用git，也可以使用SVN仓库或者本地文件系统
### 为何引入分布式配置中心
- 配置管理问题（实时生效）
- 配置内容的安全性
- 配置的修改需要重启
### 开源配置中心
- Diamond
- Apoll
- spring cloud config
- nacos
- zookeeper
### 差异化对比
- 权限管理
- 高可用特性
- 通信协议
- 数据更新的方式（pull/push）
- 是否支持多语言
- 是否支持灰度
### Spring Cloud Config
- Config Server
- Config Client
### 配置的后缀
- /{application}/{profile}/{label}
- /{application}-{profile}
- /{label}/{application}-{profile}
- application:应用名称
- profile:不同的配置分组
- label:分支
### 源码分析
##### Springboot中Environment的初始化
- SpringApplication中run方法中的prepareEnvironment();
```
	private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners,
			ApplicationArguments applicationArguments) {
		// 根据上下文，创建一个合适的Environment对象
		ConfigurableEnvironment environment = getOrCreateEnvironment();
    // 配置Environment的propertySource，以及profile
		configureEnvironment(environment, applicationArguments.getSourceArgs());
		ConfigurationPropertySources.attach(environment);
    // 通知监听器，加载配置文件
		listeners.environmentPrepared(environment);
		bindToSpringApplication(environment);
		if (!this.isCustomEnvironment) {
			environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment,
					deduceEnvironmentClass());
		}
		ConfigurationPropertySources.attach(environment);
		return environment;
	}
```
- getOrCreateEnvironment：根据当前webApplication类型匹配对应的environment
```
	private ConfigurableEnvironment getOrCreateEnvironment() {
		if (this.environment != null) {
			return this.environment;
		}
		switch (this.webApplicationType) {
		case SERVLET:
			return new StandardServletEnvironment();
		case REACTIVE:
			return new StandardReactiveWebEnvironment();
		default:
			return new StandardEnvironment();
		}
	}
```
- StandardServletEnvironment初始化过程:会初始化其父类AbstractEnvironment
```
	public AbstractEnvironment() {
		customizePropertySources(this.propertySources);
	}
```
- StandardServletEnvironment子类重写customizePropertySources方法
```
  // servlet初始化的上下文配置
	public static final String SERVLET_CONTEXT_PROPERTY_SOURCE_NAME = "servletContextInitParams";
  
  // servlet的配置信息
	public static final String SERVLET_CONFIG_PROPERTY_SOURCE_NAME = "servletConfigInitParams";

	// 加载jndi.properties配置信息
	public static final String JNDI_PROPERTY_SOURCE_NAME = "jndiProperties";

	@Override
	protected void customizePropertySources(MutablePropertySources propertySources) {
		propertySources.addLast(new StubPropertySource(SERVLET_CONFIG_PROPERTY_SOURCE_NAME));
		propertySources.addLast(new StubPropertySource(SERVLET_CONTEXT_PROPERTY_SOURCE_NAME));
		if (JndiLocatorDelegate.isDefaultJndiEnvironmentAvailable()) {
			propertySources.addLast(new JndiPropertySource(JNDI_PROPERTY_SOURCE_NAME));
		}
		super.customizePropertySources(propertySources);
	}
```
- 继续调用父类StandardEnvironment的customizePropertySources方法
```
	@Override
	protected void customizePropertySources(MutablePropertySources propertySources) {
		propertySources.addLast(
				new PropertiesPropertySource(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties())); // 系统变量，通过System.setProperty设置的变量，如java.version、os.name等
		propertySources.addLast(
				new SystemEnvironmentPropertySource(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment())); // 系统环境变量，我们配置JAVA_HOME的地方
	}

```
- 添加PropertySource的目的是告诉Environment，解析哪些位置的属性文件进行加载。
- 所有的添加都是addLast，也就是最早添加的PropertySource会放在最前面。 
- systemProperties是在systemEnvironment前面，前面的配置会覆盖后面的配置，也就是说系统变量中的配置比系统环境变量中的配置优先级更高
- MutablePropertySources：动态管理PropertySource的集合
```
public class MutablePropertySources implements PropertySources {

	private final List<PropertySource<?>> propertySourceList = new CopyOnWriteArrayList<>();

}
```
- 如何使用MutablePropertySources
```
public abstract class AbstractEnvironment implements ConfigurableEnvironment {
    private final MutablePropertySources propertySources = new MutablePropertySources();
    // AbstractEnvironment和PropertySourcesPropertyResolver都实现了ConfigurablePropertyResolver，PropertySourcesPropertyResolver中有MutablePropertySources的实例
    private final ConfigurablePropertyResolver propertyResolver = new PropertySourcesPropertyResolver(this.propertySources);
}
```
- SpringApplication.configureEnvironment
```
	protected void configureEnvironment(ConfigurableEnvironment environment, String[] args) {
		if (this.addConversionService) {
      // 添加类型转换的服务
			ConversionService conversionService = ApplicationConversionService.getSharedInstance();
			environment.setConversionService((ConfigurableConversionService) conversionService);
		}
    // 配置Environment中的propertysources
		configurePropertySources(environment, args);
    // 配置profiles
		configureProfiles(environment, args);
	}
```
- configurePropertySources（设置defaultProperties属性来源；设置commandLineProperties来源）
```
	protected void configurePropertySources(ConfigurableEnvironment environment, String[] args) {
		MutablePropertySources sources = environment.getPropertySources();
		if (this.defaultProperties != null && !this.defaultProperties.isEmpty()) {
			sources.addLast(new MapPropertySource("defaultProperties", this.defaultProperties));
		}
    // 如果设置了命令行参数，在会加载SimpleCommandLinePropertySource作为propertySource
		if (this.addCommandLineProperties && args.length > 0) {
			String name = CommandLinePropertySource.COMMAND_LINE_PROPERTY_SOURCE_NAME;
			if (sources.contains(name)) {
				PropertySource<?> source = sources.get(name);
				CompositePropertySource composite = new CompositePropertySource(name);
				composite.addPropertySource(
						new SimpleCommandLinePropertySource("springApplicationCommandLineArgs", args));
				composite.addPropertySource(source);
				sources.replace(name, composite);
			}
			else {
				sources.addFirst(new SimpleCommandLinePropertySource(args));
			}
		}
	}
```
- defaultProperties:可在启动类run方法执行前设置一些默认属性
```
public static void main(String[] args) {
  SpringApplication springApplication=new SpringApplication(SpringCloudEurekaServerApplication.class);
  Map<String, Object> pro = new HashMap<>();
  pro.put("key", "value");
  springApplication.setDefaultProperties(pro);
  springApplication.run(args);
}
```
- configureProfiles:配置当前激活的profiles
```
	protected void configureProfiles(ConfigurableEnvironment environment, String[] args) {
		Set<String> profiles = new LinkedHashSet<>(this.additionalProfiles);
		profiles.addAll(Arrays.asList(environment.getActiveProfiles()));
		environment.setActiveProfiles(StringUtils.toStringArray(profiles));
	}
```
