### 计算机原码、反码、补码
###### 原码
- 第一位是符号位，其余位表示值，范围[11111111,01111111],即[-127,127]
###### 反码
- 整数反码是其本身，负数反码是符号位保持不变，其余位取反，-1原码10000001，反码11111110
###### 补码
- 整数补码是其本身，负数补码是在其反码的基础上+1，-1补码11111111
###### 为什么要使用反码和补码
- 原码参与计算存在问题，增加二进制单位时(左移位及+1操作),负数呈现递减，正数呈现递增，原码无法满足负数的加法：1+-1=[0000_00001]原+[1000_0001]原=[1000_0010]原=-2
- 使用反码时可以满足同步递增的要求：-2+1=[1111_1101]反+[0000_0001]反=[1111_1110]反=-1，但是在跨0时的计算会有误差：-1+2=[1111_1110]反+[0000_0010]反=[0000_0000]反=0
- 有个不合理的地方，就是[1111_1111]和[0000_0000]都表示0，这导致在实际计算中每当跨过0一次，就有一个单位的误差
- 有一个[1000_0000]的二进制没有对应任何真数，于是就规定了这个数的真数是-128所以补码的表示范围是[-128~127] ，这样一来256个二进制正好表示256个整数，在实际二进制的运算中超过范围其实就是对256的取余预算（x+128）mod 256 - 128
### HashMap的get和put的时间开销
###### JDK8以前
- GET最好情况O(1)
- GET最坏情况O(N)，即单链表查询的时间复杂度
- PUT最好情况O(1)
- PUT最坏情况O(1)，jdk8前采用头插法，即在单链表头部直接插入，不需要遍历
###### JDK8以后
- GET最好情况O(1)
- GET最坏情况(当桶内元素小于6个)O(N)，即单链表查询的时间复杂度
- GET最坏情况(当桶内元素大于8个)O(logN)，红黑树查询的时间复杂度与二分查找类似
### class文件加载过程
###### 顺序
- 加载 -> 验证 -> 准备 -> 解析 -> 初始化
###### 加载
- 根据类的全名限定符，获取class二进制流（保存到硬盘的class文件，不是class二进制流获取的唯一方式。也有可能从网络中获取等）
- 将类的静态存储结构转化为方法区的运行时动态存储结构
- 在内存的堆中生成对应的class对象，作为方法区的入口
###### 验证
- class文件格式验证（class文件来源不唯一(自己也可以手写)，有可能格式正确损坏虚拟机）
- 元数据验证（是否符合类的定义规范，例如是否继承java.lang.Object）
- 字节码验证（类中方法的控制流是否合法）
- 符号引用验证（转换为直接引用动作是否合法）
###### 准备
- 为类变量在方法区分配内存，并初始化类变量（“零值”初始化）
###### 解析
- 将常量池的符号引用替换为直接引用
###### 初始化
- 在准备阶段已经对类变量进行初始化了，这里的初始化是执行类构造器<clinit>。
- <clinit>()方法是编译器自动收集类中所有类变量的赋值动作和静态代码块而产生的方法（无论类变量和静态代码块的位置是什么样，都是先执行类变量的赋值动作，再执行静态代码块）
###### 初始化触发的条件，有且只有4个（主动引用）
- new（实例化对象）、getstatic（获取类变量的值，被final修饰的除外，他的值在编译器时放到了常量池）、putstatic（给类变量赋值）、invokestatic（调用静态方法）
- 使用java.lang.reflect包的方法对类进行反射调用方法
- 初始化类的时候，如果他的父类还没有初始化，要先初始化父类
- 虚拟机启动时，含有main方法的类，会被先初始化
###### 被动引用（除了上面引用类的四个条件会触发类的初始化，其他对类的引用都不会触发类的初始化）
- 在第三方类中，使用子类引用父类的类变量，不会初始化子类
- 在第三方类中，通过数组定义来引用类，不会初始化类
- 在第三方类中，引用类的常类变量（同时被final和static修饰的变量），不会触发类的初始化（因为在第三方类的编译之后，常量就被放在第三方类的常量池中了）
###### 虚拟机的内存分配情况
- 虚拟机栈：每个class类对应一个虚拟机栈帧（组成：局部变量表、操作数栈、返回地址、动态链接），类私有
- 堆：存放对象
- 方法区：存放类信息、常量、类变量、即时编译器编译后的代码
- 常量池：是方法区的一部分，主要有字面量（常量和字符串）和符号引用（类和接口的符号引用、字段的名称和描述的符号引用、方法的名称和描述的符号引用）
### hibernate缓存
###### 一级缓存
- hibernate的一级缓存是session级别的缓存，一级缓存hibernate默认启用且不能被卸载，一个事务内有效。
- 特点：
1. 使用一级缓存的目的是为了减少对数据库的访问次数，从而提升hibernate的执行效率；（当执行一次查询操作的时候，执行第二次查询操作，先检查缓存中是否有数据，如果有数据就不查询数据库，直接从缓存中获取数据）；
2. Hibernate中的一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数，只在session范围内有效，session关闭，一级缓存失败；
3. 一级缓存的特点，只在session范围有效，作用时间短，效果不是特别明显，在短时间内多次操作数据库，效果比较明显。
4. 当调用session的save/saveOrUpdate/get/load/list/iterator方法的时候，都会把对象放入session缓存中；
5. session的缓存是由hibernate维护的，用户不能操作缓存内容；如果想操作缓存内容，必须通过hibernate提供的evict/clear方法操作
6. 缓存相关的方法（在什么情况下使用上面方法呢？批量操作情况下使用，如Session.flush();先与数据库同步，Session.clear();再清空一级缓存内容）：
```
  session.flush();让一级缓存与数据库同步；
  session.evict();清空一级缓存中指定的对象；
  session.clear();清空一级缓存中所有的对象；
```
- 综上： 一级缓存的生命周期和session的生命周期一致，当前session一旦关闭，一级缓存就消失了，因此一级缓存也叫session级的缓存或事务级缓存，一级缓存只存实体对象，它不会缓存一般的对象属性（查询缓存可以），即当获得对象后，就将该对象缓存起来，如果在同一session中再去获取这个对象时，它会先判断在缓存中有没有该对象的id，如果有则直接从缓存中获取此对象，反之才去数据库中取，取的同时再将此对象作为一级缓存处理。
###### 二级缓存
- Hibernate的二级缓存又称为"SessionFactory的缓存"，由于SessionFactory对象的生命周期和应用的整个过程对应，他是可选的，是一个可配置的插件，默认情况下SessionFactory不会启用这个插件。
- 由于二级缓存是被各session共享的，那么多个事务或者说线程同时访问修改二级缓存可能会会造成数据不一致问题。所以二级缓存只适合多读少写的场景。
- 那么什么样的数据适合放在二级缓存中呢？
1. 多读少写的数据
2. 不是很重要的数据
3. 常量数据
- 什么样的数据不适合放在二级缓存中呢？
1. 经常被修改的数据
2. 绝对不允许出现并发访问的数据。如财务数据，绝对不允许出现并发
3. 与其他应用共享的数据
### java中字符串在UTF-8 GBK unicode编码下占内存位数
###### GBK
- 一个汉字占两个字节，英文字母占两个字节
###### UTF-8
- UTF-8编码是变长编码，通常汉字占三个字节，扩展B区以后的汉字占四个字节，英文字母占两个字节。
###### UTF-16
- 通常汉字占两个字节，CJKV扩展B区、扩展C区、扩展D区中的汉字占四个字节（一般字符的Unicode范围是U+0000至U+FFFF，而这些扩展部分的范围大于U+20000，因而要用两个UTF-16），英文字母占两个字节。
###### unicode
- 汉字占2~4个字节，英文字母占两个字节
### 在@Transactional注解中，可以propagation属性用来配置事务传播，支持7种不同的传播机制：
- REQUIRED：业务方法需要在一个事务中运行，如果方法运行时，已处在一个事务中，那么就加入该事务，否则自己创建一个新的事务。这是spring默认的传播行为。
- NOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为他开启事务，如果方法在一个事务中被调用，该事务会被挂起，调用结束后，原先的事务会恢复执行。
- REQUIRESNEW：不管是否存在事务，该方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务挂起，新的事务被创建。
- MANDATORY：该方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果在没有事务的环境下被调用，容器抛出例外。
- SUPPORTS：该方法在某个事务范围内被调用，则方法成为该事务的一部分。如果方法在该事务范围外被调用，该方法就在没有事务的环境下执行。
- NEVER：该方法绝对不能在事务范围内执行。如果在就抛异常。只有该方法没有关联到任何事务，才正常执行。
- NESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中。如果没有活动事务，则按REQUIRED属性执行。它使用了一个单独的事务，这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。
### jvm参数
###### java -Xms128m -Xmx1024
- -Xms设置初始java堆大小
- -Xmx设置最大java堆大小
- 生产环境一般配置为二者相等，一是生产环境多为独占机器，二是每次调整jvm堆申请的大小都需要一定的系统开销
### ThreadPoolExecutor
https://blog.csdn.net/liuxiao723846/article/details/108026782
### 动态代理
- 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP 
- 如果目标对象实现了接口，可以强制使用CGLIB实现AOP 
- 如果目标对象没有实现了接口，必须采用CGLIB库，spring会自动在JDK动态代理和CGLIB之间转换
###### jdk动态代理
- java动态代理是利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理
- JDK动态代理只能对实现了接口的类生成代理，而不能针对类
###### cglib动态代理
- 而cglib动态代理是利用asm开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。
- CGLIB是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法
### 可以作为GC ROOTS的对象
- 虚拟机栈中引用的对象;
- 方法区中的类静态属性引用的对象;
- 方法区中常量引用的对象;
- 本地方法栈中JNI中引用的对象
### 数据库索引
- 主键索引和唯一索引可保证数据的唯一性
- 每张表只能有一个主键，所谓的多个主键，称之为联合主键
### java interface中默认修饰符
- 成员变量：static final
- 方法：public abstract
### 内部类
- 内部类可以访问外部类private属性
- 外部类不可以访问内部类的属性
