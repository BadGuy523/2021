### 计算机原码、反码、补码
###### 原码
- 第一位是符号位，其余位表示值，范围[11111111,01111111],即[-127,127]
###### 反码
- 整数反码是其本身，负数反码是符号位保持不变，其余位取反，-1原码10000001，反码11111110
###### 补码
- 整数补码是其本身，负数补码是在其反码的基础上+1，-1补码11111111
###### 为什么要使用反码和补码
- 原码参与计算存在问题，增加二进制单位时(左移位及+1操作),负数呈现递减，正数呈现递增，原码无法满足负数的加法：1+-1=[0000_00001]原+[1000_0001]原=[1000_0010]原=-2
- 使用反码时可以满足同步递增的要求：-2+1=[1111_1101]反+[0000_0001]反=[1111_1110]反=-1，但是在跨0时的计算会有误差：-1+2=[1111_1110]反+[0000_0010]反=[0000_0000]反=0
- 有个不合理的地方，就是[1111_1111]和[0000_0000]都表示0，这导致在实际计算中每当跨过0一次，就有一个单位的误差
- 有一个[1000_0000]的二进制没有对应任何真数，于是就规定了这个数的真数是-128所以补码的表示范围是[-128~127] ，这样一来256个二进制正好表示256个整数，在实际二进制的运算中超过范围其实就是对256的取余预算（x+128）mod 256 - 128
### HashMap的get和put的时间开销
###### JDK8以前
- GET最好情况O(1)
- GET最坏情况O(N)，即单链表查询的时间复杂度
- PUT最好情况O(1)
- PUT最坏情况O(1)，jdk8前采用头插法，即在单链表头部直接插入，不需要遍历
###### JDK8以后
- GET最好情况O(1)
- GET最坏情况(当桶内元素小于6个)O(N)，即单链表查询的时间复杂度
- GET最坏情况(当桶内元素大于8个)O(logN)，红黑树查询的时间复杂度与二分查找类似
### class文件加载过程
###### 顺序
- 加载 -> 验证 -> 准备 -> 解析 -> 初始化
###### 加载
- 根据类的全名限定符，获取class二进制流（保存到硬盘的class文件，不是class二进制流获取的唯一方式。也有可能从网络中获取等）
- 将类的静态存储结构转化为方法区的运行时动态存储结构
- 在内存的堆中生成对应的class对象，作为方法区的入口
###### 验证
- class文件格式验证（class文件来源不唯一(自己也可以手写)，有可能格式正确损坏虚拟机）
- 元数据验证（是否符合类的定义规范，例如是否继承java.lang.Object）
- 字节码验证（类中方法的控制流是否合法）
- 符号引用验证（转换为直接引用动作是否合法）
###### 准备
- 为类变量在方法区分配内存，并初始化类变量（“零值”初始化）
###### 解析
- 将常量池的符号引用替换为直接引用
###### 初始化
- 在准备阶段已经对类变量进行初始化了，这里的初始化是执行类构造器<clinit>。
- <clinit>()方法是编译器自动收集类中所有类变量的赋值动作和静态代码块而产生的方法（无论类变量和静态代码块的位置是什么样，都是先执行类变量的赋值动作，再执行静态代码块）
###### 初始化触发的条件，有且只有4个（主动引用）
- new（实例化对象）、getstatic（获取类变量的值，被final修饰的除外，他的值在编译器时放到了常量池）、putstatic（给类变量赋值）、invokestatic（调用静态方法）
- 使用java.lang.reflect包的方法对类进行反射调用方法
- 初始化类的时候，如果他的父类还没有初始化，要先初始化父类
- 虚拟机启动时，含有main方法的类，会被先初始化
###### 被动引用（除了上面引用类的四个条件会触发类的初始化，其他对类的引用都不会触发类的初始化）
- 在第三方类中，使用子类引用父类的类变量，不会初始化子类
- 在第三方类中，通过数组定义来引用类，不会初始化类
- 在第三方类中，引用类的常类变量（同时被final和static修饰的变量），不会触发类的初始化（因为在第三方类的编译之后，常量就被放在第三方类的常量池中了）
###### 虚拟机的内存分配情况
- 虚拟机栈：每个class类对应一个虚拟机栈帧（组成：局部变量表、操作数栈、返回地址、动态链接），类私有
- 堆：存放对象
- 方法区：存放类信息、常量、类变量、即时编译器编译后的代码
- 常量池：是方法区的一部分，主要有字面量（常量和字符串）和符号引用（类和接口的符号引用、字段的名称和描述的符号引用、方法的名称和描述的符号引用）
### hibernate缓存
###### 一级缓存
- hibernate的一级缓存是session级别的缓存，一级缓存hibernate默认启用且不能被卸载，一个事务内有效。
- 特点：
1. 使用一级缓存的目的是为了减少对数据库的访问次数，从而提升hibernate的执行效率；（当执行一次查询操作的时候，执行第二次查询操作，先检查缓存中是否有数据，如果有数据就不查询数据库，直接从缓存中获取数据）；
2. Hibernate中的一级缓存，也叫做session的缓存，它可以在session范围内减少数据库的访问次数，只在session范围内有效，session关闭，一级缓存失败；
3. 一级缓存的特点，只在session范围有效，作用时间短，效果不是特别明显，在短时间内多次操作数据库，效果比较明显。
4. 当调用session的save/saveOrUpdate/get/load/list/iterator方法的时候，都会把对象放入session缓存中；
5. session的缓存是由hibernate维护的，用户不能操作缓存内容；如果想操作缓存内容，必须通过hibernate提供的evict/clear方法操作
6. 缓存相关的方法（在什么情况下使用上面方法呢？批量操作情况下使用，如Session.flush();先与数据库同步，Session.clear();再清空一级缓存内容）：
```
  session.flush();让一级缓存与数据库同步；
  session.evict();清空一级缓存中指定的对象；
  session.clear();清空一级缓存中所有的对象；
```
- 综上： 一级缓存的生命周期和session的生命周期一致，当前session一旦关闭，一级缓存就消失了，因此一级缓存也叫session级的缓存或事务级缓存，一级缓存只存实体对象，它不会缓存一般的对象属性（查询缓存可以），即当获得对象后，就将该对象缓存起来，如果在同一session中再去获取这个对象时，它会先判断在缓存中有没有该对象的id，如果有则直接从缓存中获取此对象，反之才去数据库中取，取的同时再将此对象作为一级缓存处理。
###### 二级缓存
- Hibernate的二级缓存又称为"SessionFactory的缓存"，由于SessionFactory对象的生命周期和应用的整个过程对应，他是可选的，是一个可配置的插件，默认情况下SessionFactory不会启用这个插件。
- 由于二级缓存是被各session共享的，那么多个事务或者说线程同时访问修改二级缓存可能会会造成数据不一致问题。所以二级缓存只适合多读少写的场景。
- 那么什么样的数据适合放在二级缓存中呢？
1. 多读少写的数据
2. 不是很重要的数据
3. 常量数据
- 什么样的数据不适合放在二级缓存中呢？
1. 经常被修改的数据
2. 绝对不允许出现并发访问的数据。如财务数据，绝对不允许出现并发
3. 与其他应用共享的数据
### java中字符串在UTF-8 GBK unicode编码下占内存位数
###### GBK
- 
###### UTF-8
- 
###### UTF-16
- 
###### unicode
- 
  
  
